# LTL语法简介

首先你应该了解什么是一阶逻辑，包括基础的与&&、或||、非~、蕴含==>，这里不过多赘述这一部分。	

## 霍尔逻辑

$(|\phi|)P(|\psi|)$的形式成为霍尔三元组，其中$\phi$称为前置条件，$\psi$称为后置条件。

简单来说其含义为，程序P在运行前满足$\phi$条件，运行后满足$\psi$条件，则该表达式成立。

## LTL

线性时序逻辑（linear temporal logic， LTL）

#### 语法

递归定义LTL公式：

1. 原子命题，true，false是LTL公式；

2. 如果$\phi和\psi$是LTL公式，那么

   $\neg \phi,\phi \land \psi,\phi \lor \psi,F(\phi),G(\phi),X(\phi),\phi U \psi$

   也是LTL公式。

#### LTL时序操作

- $X$：$X$q，下一个时刻q为真
- $G$：$G$ q，事件q在全局都为真，记作[]
- $F$：$F$ q，未来某个时刻事件q为真，记作<>
- $U$：表示为 q $U$ p，事件q为真直到事件p发生

> 如果你对LTL想要进一步学习，推荐阅读[《handbook of model checking》CH1-2](https://link.springer.com/book/10.1007/978-3-319-10575-8)，了解时序逻辑的基础。

#### 例子

-  (𝑥 == 0) ˄ (𝑥 += 3) → 𝑋(𝑥 == 3)：   当前x为0且+3，则下一个时刻x为3
- 𝑠𝑎𝑑 → 𝐹(ℎ𝑎𝑝𝑝𝑦)： 未来终会高兴
- 𝐺 (ℎ𝑎𝑝𝑝𝑦)：一直都会高兴
-   (𝑤𝑜𝑟𝑘_ℎ𝑎𝑟𝑑) 𝑈 (𝑠𝑢𝑐𝑐𝑒𝑠𝑠)  ：革命尚未成功，同志仍需努力

> 由于LTL所表示的时序在全局情况下可能表示无限，因此“lasso”结构是有必要了解的，其形式为 $v \cdot w^\omega$,  含义为一个有限路径后面跟着一个无限重复的路径。

## SmartLTL

SmartLTL是一种类LTL的针对智能合约的特定语言。可以简单的理解为，SmartLTL只是LTL的一种扩充形式，其公式的形式还包括以下几类：

- $start(f,\psi)$：一条调用函数$f$的交易，满足条件$\psi$，开始执行，则返回true。

- $finish(f,\psi)$：如果交易$f$在状态$\psi$下成功执行完成，则返回true。
- $revert(f,\psi)$：在状态$\psi$下交易回退，则返回true。
- $send(\psi)$ ：$start(transfer,\psi)$的语法糖。

注：第一二条常用。

- $csum(v)$：$v$变量中存储值的和。
- $fsum(f,v,\psi)$：在$\psi$条件下$f$中变量$v$的值的和。

#### 规范结构

SmartLTL规约可包含三部分：自由变量声明、公平性属性、待验证属性。

- 自由变量：可用于表示某些变量具体的值。
- 公平性属性：表示该事件一定会发生。
- 待验证属性：工具需要验证的属性。

#### 原子公式

与上述符号对应，f为函数名，$\psi$为一阶逻辑。

- started(f, $\psi$)
- finished(f, $\psi$)
- reverted(f, $\psi$)
- sent($\psi$)

#### 验证属性

SmartLTL包含这样的一个规约公式：

$(\phi_F,\phi_P)$，前者是公平性假设，后者是要验证的属性，即最终则是要验证是否存在反例$(\phi_F \land \neg \phi_P)$。

> [支持场景](availableSpec.md)对目前工具支持的规约有更多的解释和说明。

> 现在，回到[示例部分](README.md)，更进一步理解示例。

